<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Neon Dodge - Mini Juego 2D</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    :root {
      --bg: #050510;
      --accent: #ff4b8a;
      --accent2: #46e0ff;
      --text: #f5f5f5;
      --muted: #b3b3c9;
      --power-shield: #ffe45e;
      --power-slow: #7bffb5;
      --power-burst: #ff9cf5;
      --power-dash: #4ea3ff;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: radial-gradient(circle at top, #1b1030 0, #050510 55%, #020208 100%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .game-wrapper {
      position: relative;
      width: min(900px, 100vw - 32px);
      aspect-ratio: 3 / 2;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.09);
      box-shadow: 0 20px 50px rgba(0,0,0,0.7);
      overflow: hidden;
      background: radial-gradient(circle at top, rgba(255,255,255,0.08), transparent 55%);
    }

    canvas {
      width: 100%;
      height: 100%;
      display: block;
      background: radial-gradient(circle at center, #16132a 0, #050511 60%, #020208 100%);
    }

    .hud {
      pointer-events: none;
      position: absolute;
      inset: 0;
      padding: 12px 16px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      font-size: 0.9rem;
    }

    .hud-top {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
    }

    .hud-box {
      background: rgba(5,5,20,0.8);
      border-radius: 12px;
      padding: 6px 10px;
      border: 1px solid rgba(255,255,255,0.1);
      backdrop-filter: blur(6px);
      box-shadow: 0 8px 18px rgba(0,0,0,0.6);
    }

    .hud-label {
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--muted);
      margin-bottom: 2px;
    }

    .hud-value {
      font-size: 1rem;
    }

    .hud-controls {
      text-align: right;
      font-size: 0.75rem;
      color: var(--muted);
    }

    .hud-controls b {
      color: var(--accent2);
    }

    .hud-bottom {
      margin-top: auto;
      display: flex;
      justify-content: flex-start;
      align-items: flex-end;
    }

    .hud-bottom-box {
      font-size: 0.8rem;
    }

    .hud-tag-row {
      display: flex;
      gap: 0.4rem;
      flex-wrap: wrap;
      margin-top: 2px;
    }

    .hud-tag {
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.12);
      font-size: 0.75rem;
      color: var(--muted);
      background: rgba(0,0,0,0.4);
    }

    .hud-tag-active {
      color: #000;
      font-weight: 500;
    }

    .hud-tag-active.shield {
      background: var(--power-shield);
      border-color: rgba(0,0,0,0.2);
    }

    .hud-tag-active.slow {
      background: var(--power-slow);
      border-color: rgba(0,0,0,0.2);
    }

    .hud-tag-active.burst {
      background: var(--power-burst);
      border-color: rgba(0,0,0,0.2);
    }

    .hud-tag-active.dash {
      background: var(--power-dash);
      border-color: rgba(0,0,0,0.2);
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    .panel {
      pointer-events: auto;
      background: radial-gradient(circle at top, rgba(21,16,40,0.95), rgba(5,5,20,0.95));
      border-radius: 20px;
      padding: 20px 24px;
      max-width: 420px;
      width: 90%;
      border: 1px solid rgba(255,255,255,0.12);
      box-shadow: 0 18px 40px rgba(0,0,0,0.8);
      text-align: center;
    }

    .panel-title {
      font-size: 1.4rem;
      margin-bottom: 6px;
    }

    .panel-sub {
      font-size: 0.9rem;
      color: var(--muted);
      margin-bottom: 12px;
    }

    .panel-sub span {
      color: var(--accent2);
    }

    .panel-score {
      margin: 8px 0 14px;
      font-size: 0.95rem;
    }

    .btn-row {
      display: flex;
      gap: 0.6rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 4px;
    }

    button.game-btn {
      border: none;
      outline: none;
      cursor: pointer;
      border-radius: 999px;
      padding: 8px 18px;
      font-size: 0.9rem;
      font-weight: 500;
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      background: linear-gradient(120deg, var(--accent), var(--accent2));
      color: #fff;
      box-shadow: 0 12px 28px rgba(0,0,0,0.8);
      transition: transform 0.12s ease, box-shadow 0.12s ease, opacity 0.15s;
    }

    button.game-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 16px 34px rgba(0,0,0,0.9);
    }

    button.game-btn.secondary {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.35);
      color: var(--muted);
      box-shadow: none;
    }

    button.game-btn.secondary:hover {
      color: var(--text);
      border-color: var(--accent2);
      box-shadow: 0 10px 26px rgba(0,0,0,0.7);
    }

    .panel-tip {
      font-size: 0.75rem;
      color: var(--muted);
      margin-top: 10px;
    }

    @media (max-width: 600px) {
      .panel {
        padding: 16px 16px;
      }
      .panel-title {
        font-size: 1.2rem;
      }
      .hud-box {
        padding: 6px 8px;
      }
      .hud-value {
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <div class="game-wrapper">
    <canvas id="game"></canvas>

    <div class="hud">
      <div class="hud-top">
        <div class="hud-box">
          <div class="hud-label">Puntuación</div>
          <div class="hud-value" id="scoreText">0</div>
        </div>
        <div class="hud-controls">
          <div><b>WASD / Flechas</b> · mover</div>
          <div><b>Shift</b> · dash · <b>Espacio</b> · pausa</div>
        </div>
      </div>

      <div class="hud-bottom">
        <div class="hud-box hud-bottom-box">
          <div class="hud-label">Power-ups</div>
          <div class="hud-tag-row">
            <span id="shieldStatus" class="hud-tag">Escudo: —</span>
            <span id="slowStatus" class="hud-tag">Lento: —</span>
            <span id="burstStatus" class="hud-tag">Ráfaga: —</span>
            <span id="dashStatus" class="hud-tag">Dash: —</span>
          </div>
        </div>
      </div>
    </div>

    <!-- Overlays de menú / game over -->
    <div class="overlay" id="menuOverlay">
      <div class="panel">
        <div class="panel-title">NEON DODGE</div>
        <div class="panel-sub">
          Sobrevive el mayor tiempo posible esquivando los fragmentos de energía.
          <br>
          <span>Escudo y slow stackeables, ráfaga que limpia la pantalla y dash con iframes.</span>
        </div>
        <div class="panel-score" id="menuBestScore" style="display:none;"></div>
        <div class="btn-row">
          <button class="game-btn" id="btnStart">▶ Empezar</button>
        </div>
        <div class="panel-tip">
          Controles: WASD / flechas para moverte · Shift para dash · Espacio para pausar.
        </div>
      </div>
    </div>

    <div class="overlay" id="gameOverOverlay" style="display:none;">
      <div class="panel">
        <div class="panel-title">Fin de la ronda</div>
        <div class="panel-sub">
          Te alcanzó un fragmento de energía.  
          Usa bien el escudo, slow, ráfaga y dash para sobrevivir más.
        </div>
        <div class="panel-score">
          Puntuación: <span id="finalScore">0</span><br>
          Mejor puntuación: <span id="bestScore">0</span>
        </div>
        <div class="btn-row">
          <button class="game-btn" id="btnRetry">↻ Jugar de nuevo</button>
          <button class="game-btn secondary" id="btnMenu">Menú principal</button>
        </div>
      </div>
    </div>

  </div>

  <script>
    (function () {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      // Tamaño interno del juego
      const GAME_WIDTH = 900;
      const GAME_HEIGHT = 600;
      canvas.width = GAME_WIDTH;
      canvas.height = GAME_HEIGHT;

      // Estados del juego
      const STATE = {
        MENU: "menu",
        PLAYING: "playing",
        PAUSED: "paused",
        GAMEOVER: "gameover",
      };

      let currentState = STATE.MENU;

      // HUD
      const scoreText = document.getElementById("scoreText");
      const menuOverlay = document.getElementById("menuOverlay");
      const gameOverOverlay = document.getElementById("gameOverOverlay");
      const finalScoreText = document.getElementById("finalScore");
      const bestScoreText = document.getElementById("bestScore");
      const menuBestScoreText = document.getElementById("menuBestScore");
      const shieldStatus = document.getElementById("shieldStatus");
      const slowStatus = document.getElementById("slowStatus");
      const burstStatus = document.getElementById("burstStatus");
      const dashStatus = document.getElementById("dashStatus");

      const btnStart = document.getElementById("btnStart");
      const btnRetry = document.getElementById("btnRetry");
      const btnMenu = document.getElementById("btnMenu");

      // Sistema de sonido simple (Web Audio)
      let audioCtx = null;
      function initAudio() {
        if (!audioCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (AC) {
            audioCtx = new AC();
          }
        }
      }

      function playTone(freq, duration, type = "sine", volume = 0.35) {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.value = freq;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        gain.gain.setValueAtTime(volume, now);
        gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
        osc.start(now);
        osc.stop(now + duration);
      }

      function playStartSound() {
        playTone(440, 0.12, "square", 0.3);
        playTone(660, 0.12, "square", 0.2);
      }

      function playPickupSoundShield() {
        playTone(700, 0.09, "sine", 0.3);
        playTone(950, 0.11, "sine", 0.25);
      }

      function playPickupSoundSlow() {
        playTone(520, 0.11, "triangle", 0.3);
        playTone(380, 0.14, "triangle", 0.25);
      }

      function playPickupSoundBurst() {
        playTone(900, 0.08, "square", 0.25);
        playTone(1200, 0.08, "square", 0.25);
      }

      function playPickupSoundDash() {
        playTone(650, 0.06, "triangle", 0.25);
        playTone(1050, 0.06, "triangle", 0.2);
      }

      function playHitSound() {
        playTone(140, 0.18, "sawtooth", 0.4);
        playTone(90, 0.25, "sawtooth", 0.35);
      }

      function playShieldBreakSound() {
        playTone(420, 0.1, "square", 0.3);
        playTone(230, 0.12, "square", 0.25);
      }

      function playBurstStepSound() {
        playTone(750, 0.05, "sine", 0.25);
      }

      function playDashSound() {
        playTone(300, 0.05, "sine", 0.25);
        playTone(600, 0.08, "sine", 0.2);
      }

      // Jugador
      const player = {
        x: GAME_WIDTH / 2,
        y: GAME_HEIGHT / 2,
        radius: 14,
        speed: 260,
        colorInner: "#ffffff",
        colorOuter: "#46e0ff"
      };

      // Entrada
      const keys = {};
      window.addEventListener("keydown", (e) => {
        const k = e.key.toLowerCase();
        if (["arrowup","arrowdown","arrowleft","arrowright"," ","shift"].includes(k)) {
          e.preventDefault();
        }
        keys[k] = true;

        if (e.code === "Space") {
          if (currentState === STATE.PLAYING) {
            currentState = STATE.PAUSED;
          } else if (currentState === STATE.PAUSED) {
            currentState = STATE.PLAYING;
          }
        }

        if (e.key === "Shift" || e.code === "ShiftLeft" || e.code === "ShiftRight") {
          tryStartDash();
        }
      });

      window.addEventListener("keyup", (e) => {
        const k = e.key.toLowerCase();
        keys[k] = false;
      });

      // Enemigos, partículas y power-ups
      let enemies = [];
      let particles = [];
      let powerups = [];

      const POWERUP = {
        SHIELD: "shield",
        SLOW: "slow",
        BURST: "burst",
        DASH: "dash",
      };

      // Power-ups activos
      let shieldActive = false;
      let shieldTime = 0;
      let shieldStacks = 0;
      const SHIELD_DURATION = 5; // segundos por pickup

      let slowActive = false;
      let slowTime = 0;
      const SLOW_DURATION = 4;
      const SLOW_MAX = 15; // por seguridad

      const SLOW_FACTOR = 0.45;

      // Time Breaker / Ráfaga
      let burstActive = false;
      let burstQueue = [];
      let burstTimer = 0;
      const BURST_INTERVAL = 0.06;

      // Dash
      let dashCharges = 0;
      let dashActive = false;
      let dashTimer = 0;
      let dashRecoverTimer = 0;
      let dashDirX = 0;
      let dashDirY = -1;
      const DASH_DURATION = 0.18;
      const DASH_RECOVERY = 0.12;
      const DASH_SPEED_MULT = 4.5;

      let lastMoveDirX = 0;
      let lastMoveDirY = -1;

      function updateDashStatus() {
        if (dashCharges <= 0) {
          dashStatus.textContent = "Dash: —";
          dashStatus.classList.remove("hud-tag-active", "dash");
        } else {
          const cText = dashCharges === 1 ? "1 carga" : dashCharges + " cargas";
          dashStatus.textContent = "Dash: " + cText;
          dashStatus.classList.add("hud-tag-active", "dash");
        }
      }

      function tryStartDash() {
        if (currentState !== STATE.PLAYING) return;
        if (dashCharges <= 0) return;
        if (dashActive || dashRecoverTimer > 0 || burstActive) return;

        let dx = lastMoveDirX;
        let dy = lastMoveDirY;
        if (dx === 0 && dy === 0) {
          dy = -1;
        }

        dashDirX = dx;
        dashDirY = dy;
        dashActive = true;
        dashTimer = DASH_DURATION;
        dashRecoverTimer = 0;
        dashCharges -= 1;
        updateDashStatus();
        playDashSound();
      }

      function spawnEnemy(elapsedTime) {
        const baseSpeed = 80;
        const bonus = Math.min(elapsedTime * 4, 220);
        const speed = baseSpeed + bonus + Math.random() * 60;

        const size = 10 + Math.random() * 16;
        const side = Math.floor(Math.random() * 4);
        let x, y;
        if (side === 0) {
          x = Math.random() * GAME_WIDTH;
          y = -size * 2;
        } else if (side === 1) {
          x = GAME_WIDTH + size * 2;
          y = Math.random() * GAME_HEIGHT;
        } else if (side === 2) {
          x = Math.random() * GAME_WIDTH;
          y = GAME_HEIGHT + size * 2;
        } else {
          x = -size * 2;
          y = Math.random() * GAME_HEIGHT;
        }

        const dirX = player.x - x + (Math.random() - 0.5) * 120;
        const dirY = player.y - y + (Math.random() - 0.5) * 120;
        const len = Math.hypot(dirX, dirY) || 1;
        const vx = (dirX / len) * speed;
        const vy = (dirY / len) * speed;

        enemies.push({
          x, y, vx, vy,
          size,
          hue: 200 + Math.random() * 120
        });
      }

      function spawnBurst(x, y, hueBase) {
        for (let i = 0; i < 16; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 40 + Math.random() * 140;
          particles.push({
            x,
            y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            life: 0.6 + Math.random() * 0.4,
            elapsed: 0,
            hue: hueBase + (Math.random()*40 - 20)
          });
        }
      }

      function spawnPowerup() {
        const margin = 50;
        const x = margin + Math.random() * (GAME_WIDTH - margin * 2);
        const y = margin + Math.random() * (GAME_HEIGHT - margin * 2);

        // Distribución: escudo 35%, lento 30%, ráfaga 20%, dash 15%
        const r = Math.random();
        let type;
        if (r < 0.35) {
          type = POWERUP.SHIELD;
        } else if (r < 0.65) {
          type = POWERUP.SLOW;
        } else if (r < 0.85) {
          type = POWERUP.BURST;
        } else {
          type = POWERUP.DASH;
        }

        powerups.push({
          x,
          y,
          radius: 12,
          type,
          life: 10,
          elapsed: 0
        });
      }

      // Puntuación
      let score = 0;
      let bestScore = 0;
      let elapsedTime = 0;
      let spawnTimer = 0;
      let spawnInterval = 1.1;

      // Power-up spawn
      let powerupTimer = 0;
      let powerupInterval = 8;

      // Loop
      let lastTime = 0;

      function resetStatuses() {
        shieldActive = false;
        shieldTime = 0;
        shieldStacks = 0;
        slowActive = false;
        slowTime = 0;
        burstActive = false;
        burstQueue = [];
        burstTimer = 0;

        dashCharges = 0;
        dashActive = false;
        dashTimer = 0;
        dashRecoverTimer = 0;
        dashDirX = 0;
        dashDirY = -1;

        shieldStatus.textContent = "Escudo: —";
        slowStatus.textContent = "Lento: —";
        burstStatus.textContent = "Ráfaga: —";
        dashStatus.textContent = "Dash: —";

        shieldStatus.classList.remove("hud-tag-active", "shield");
        slowStatus.classList.remove("hud-tag-active", "slow");
        burstStatus.classList.remove("hud-tag-active", "burst");
        dashStatus.classList.remove("hud-tag-active", "dash");
      }

      function resetGame() {
        player.x = GAME_WIDTH / 2;
        player.y = GAME_HEIGHT / 2;
        enemies = [];
        particles = [];
        powerups = [];
        score = 0;
        elapsedTime = 0;
        spawnTimer = 0;
        spawnInterval = 1.1;
        powerupTimer = 0;
        powerupInterval = 5 + Math.random() * 5;
        scoreText.textContent = "0";
        lastMoveDirX = 0;
        lastMoveDirY = -1;
        resetStatuses();
      }

      function setState(newState) {
        currentState = newState;
        if (newState === STATE.MENU) {
          menuOverlay.style.display = "flex";
          gameOverOverlay.style.display = "none";
          if (bestScore > 0) {
            menuBestScoreText.style.display = "block";
            menuBestScoreText.textContent = "Mejor puntuación: " + bestScore.toFixed(1);
          }
        } else if (newState === STATE.PLAYING) {
          menuOverlay.style.display = "none";
          gameOverOverlay.style.display = "none";
        } else if (newState === STATE.GAMEOVER) {
          menuOverlay.style.display = "none";
          gameOverOverlay.style.display = "flex";
        }
      }

      // Botones
      btnStart.addEventListener("click", () => {
        initAudio();
        playStartSound();
        resetGame();
        setState(STATE.PLAYING);
      });

      btnRetry.addEventListener("click", () => {
        initAudio();
        playStartSound();
        resetGame();
        setState(STATE.PLAYING);
      });

      btnMenu.addEventListener("click", () => {
        setState(STATE.MENU);
      });

      function update(dt) {
        if (currentState !== STATE.PLAYING) return;

        elapsedTime += dt;
        score = elapsedTime * 10;
        scoreText.textContent = score.toFixed(1);

        // Dash timers
        if (dashActive) {
          dashTimer -= dt;
          if (dashTimer <= 0) {
            dashActive = false;
            dashTimer = 0;
            dashRecoverTimer = DASH_RECOVERY;
          }
        } else if (dashRecoverTimer > 0) {
          dashRecoverTimer -= dt;
          if (dashRecoverTimer < 0) dashRecoverTimer = 0;
        }

        // Spawn de enemigos (si NO hay ráfaga activa)
        const minInterval = 0.25;
        spawnInterval = Math.max(minInterval, 1.1 - elapsedTime * 0.04);
        if (!burstActive) {
          spawnTimer += dt;
          if (spawnTimer >= spawnInterval) {
            spawnTimer = 0;
            spawnEnemy(elapsedTime);
          }
        }

        // Spawn de power-ups
        powerupTimer += dt;
        if (powerupTimer >= powerupInterval) {
          powerupTimer = 0;
          powerupInterval = 7 + Math.random() * 6;
          spawnPowerup();
        }

        // Movimiento del jugador
        let dirX = 0, dirY = 0;
        if (keys["w"] || keys["arrowup"]) dirY -= 1;
        if (keys["s"] || keys["arrowdown"]) dirY += 1;
        if (keys["a"] || keys["arrowleft"]) dirX -= 1;
        if (keys["d"] || keys["arrowright"]) dirX += 1;

        const len = Math.hypot(dirX, dirY);
        if (len > 0) {
          dirX /= len;
          dirY /= len;
          lastMoveDirX = dirX;
          lastMoveDirY = dirY;
        }

        if (dashActive) {
          player.x += dashDirX * player.speed * DASH_SPEED_MULT * dt;
          player.y += dashDirY * player.speed * DASH_SPEED_MULT * dt;
        } else {
          player.x += dirX * player.speed * dt;
          player.y += dirY * player.speed * dt;
        }

        player.x = Math.max(player.radius + 4, Math.min(GAME_WIDTH - player.radius - 4, player.x));
        player.y = Math.max(player.radius + 4, Math.min(GAME_HEIGHT - player.radius - 4, player.y));

        // Actualizar power-ups (tiempo + colisión con jugador)
        const remainingPowerups = [];
        for (const p of powerups) {
          p.elapsed += dt;
          if (p.elapsed >= p.life) continue;

          const dx = p.x - player.x;
          const dy = p.y - player.y;
          const distSq = dx * dx + dy * dy;
          const rad = p.radius + player.radius;
          if (distSq <= rad * rad) {
            if (p.type === POWERUP.SHIELD) {
              shieldActive = true;
              shieldStacks += 1;
              shieldTime = Math.min(shieldTime + SHIELD_DURATION, 999);
              shieldStatus.classList.add("hud-tag-active", "shield");
              playPickupSoundShield();
            } else if (p.type === POWERUP.SLOW) {
              slowActive = true;
              slowTime = Math.min(slowTime + SLOW_DURATION, SLOW_MAX);
              slowStatus.classList.add("hud-tag-active", "slow");
              playPickupSoundSlow();
            } else if (p.type === POWERUP.BURST) {
              if (!burstActive && enemies.length > 0) {
                burstActive = true;
                burstQueue = enemies.slice();
                enemies = [];
                burstTimer = 0;
                burstStatus.classList.add("hud-tag-active", "burst");
                burstStatus.textContent = "Ráfaga: limpiando";
                playPickupSoundBurst();
              }
            } else if (p.type === POWERUP.DASH) {
              dashCharges += 1;
              updateDashStatus();
              playPickupSoundDash();
            }
            const hueChoice = p.type === POWERUP.SHIELD ? 55 :
                              p.type === POWERUP.SLOW ? 140 :
                              p.type === POWERUP.BURST ? 290 : 210;
            spawnBurst(p.x, p.y, hueChoice);
            continue;
          }
          remainingPowerups.push(p);
        }
        powerups = remainingPowerups;

        // Escudo
        if (shieldActive) {
          shieldTime -= dt;
          if (shieldTime <= 0 || shieldStacks <= 0) {
            shieldActive = false;
            shieldTime = 0;
            shieldStacks = 0;
            shieldStatus.textContent = "Escudo: —";
            shieldStatus.classList.remove("hud-tag-active", "shield");
          } else {
            const cargasText = shieldStacks === 1 ? "1 carga" : shieldStacks + " cargas";
            shieldStatus.textContent = "Escudo: " + cargasText + " · " + shieldTime.toFixed(1) + "s";
          }
        }

        // Slow motion
        if (slowActive) {
          slowTime -= dt;
          if (slowTime <= 0) {
            slowActive = false;
            slowTime = 0;
            slowStatus.textContent = "Lento: —";
            slowStatus.classList.remove("hud-tag-active", "slow");
          } else {
            slowStatus.textContent = "Lento: " + slowTime.toFixed(1) + "s";
          }
        }

        const speedFactor = slowActive ? SLOW_FACTOR : 1;
        const invincible = burstActive || dashActive || dashRecoverTimer > 0;

        // Lógica de ráfaga
        if (burstActive) {
          burstTimer += dt;
          while (burstTimer >= BURST_INTERVAL && burstQueue.length > 0) {
            burstTimer -= BURST_INTERVAL;
            const e = burstQueue.shift();
            if (!e) break;
            spawnBurst(e.x, e.y, e.hue);
            playBurstStepSound();
          }
          if (burstQueue.length === 0) {
            burstActive = false;
            burstStatus.textContent = "Ráfaga: —";
            burstStatus.classList.remove("hud-tag-active", "burst");
          }
        }

        // Actualizar enemigos (solo si NO hay ráfaga activa)
        if (!burstActive) {
          const newEnemies = [];
          for (const e of enemies) {
            e.x += e.vx * dt * speedFactor;
            e.y += e.vy * dt * speedFactor;

            if (e.x < -120 || e.x > GAME_WIDTH + 120 || e.y < -120 || e.y > GAME_HEIGHT + 120) {
              continue;
            }

            const dx = e.x - player.x;
            const dy = e.y - player.y;
            const distSq = dx * dx + dy * dy;
            const rad = e.size + player.radius;

            if (!invincible && distSq <= rad * rad) {
              if (shieldActive && shieldStacks > 0) {
                shieldStacks -= 1;
                spawnBurst(e.x, e.y, e.hue);
                playShieldBreakSound();
                if (shieldStacks <= 0) {
                  shieldActive = false;
                  shieldTime = 0;
                  shieldStacks = 0;
                  shieldStatus.textContent = "Escudo: —";
                  shieldStatus.classList.remove("hud-tag-active", "shield");
                } else {
                  const cargasText = shieldStacks === 1 ? "1 carga" : shieldStacks + " cargas";
                  shieldStatus.textContent = "Escudo: " + cargasText + " · " + shieldTime.toFixed(1) + "s";
                }
                continue;
              } else {
                spawnBurst(player.x, player.y, e.hue);
                playHitSound();
                if (score > bestScore) {
                  bestScore = score;
                }
                finalScoreText.textContent = score.toFixed(1);
                bestScoreText.textContent = bestScore.toFixed(1);
                setState(STATE.GAMEOVER);
                return;
              }
            }

            newEnemies.push(e);
          }
          enemies = newEnemies;
        }

        // Partículas
        const newParticles = [];
        for (const p of particles) {
          p.elapsed += dt;
          if (p.elapsed >= p.life) continue;
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vy += 20 * dt;
          newParticles.push(p);
        }
        particles = newParticles;
      }

      function drawBackground() {
        const grad = ctx.createRadialGradient(
          GAME_WIDTH / 2,
          GAME_HEIGHT / 2,
          0,
          GAME_WIDTH / 2,
          GAME_HEIGHT / 2,
          GAME_WIDTH * 0.7
        );
        grad.addColorStop(0, "#1a1530");
        grad.addColorStop(0.4, "#090718");
        grad.addColorStop(1, "#050510");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        ctx.save();
        ctx.translate(GAME_WIDTH / 2, GAME_HEIGHT / 2);
        ctx.strokeStyle = "rgba(255,255,255,0.04)";
        ctx.lineWidth = 1;
        for (let r = 120; r < 420; r += 70) {
          ctx.beginPath();
          ctx.arc(0, 0, r, 0, Math.PI * 2);
          ctx.stroke();
        }
        ctx.restore();
      }

      function drawPlayer() {
        ctx.save();
        ctx.translate(player.x, player.y);

        const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, player.radius * 2.1);
        gradient.addColorStop(0, "rgba(70,224,255,0.7)");
        gradient.addColorStop(0.4, "rgba(70,224,255,0.35)");
        gradient.addColorStop(1, "rgba(70,224,255,0)");

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(0, 0, player.radius * 2.1, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowColor = "#46e0ff";
        ctx.shadowBlur = 15;
        ctx.fillStyle = player.colorOuter;
        ctx.beginPath();
        ctx.arc(0, 0, player.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.fillStyle = player.colorInner;
        ctx.beginPath();
        ctx.arc(0, 0, player.radius * 0.55, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "rgba(0,0,0,0.4)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(0, 0, player.radius * 0.75, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
      }

      function drawEnemies() {
        for (const e of enemies) {
          ctx.save();
          ctx.translate(e.x, e.y);

          const angle = Math.atan2(player.y - e.y, player.x - e.x);
          ctx.rotate(angle + Math.PI / 4);

          const grad = ctx.createLinearGradient(-e.size, -e.size, e.size, e.size);
          grad.addColorStop(0, `hsla(${e.hue}, 80%, 60%, 0.1)`);
          grad.addColorStop(1, `hsla(${e.hue}, 90%, 60%, 0.9)`);

          ctx.shadowColor = `hsla(${e.hue}, 100%, 60%, 0.9)`;
          ctx.shadowBlur = 18;
          ctx.fillStyle = grad;
          ctx.strokeStyle = `hsla(${e.hue}, 95%, 70%, 1)`;
          ctx.lineWidth = 1.4;

          ctx.beginPath();
          ctx.moveTo(0, -e.size);
          ctx.lineTo(e.size, 0);
          ctx.lineTo(0, e.size);
          ctx.lineTo(-e.size, 0);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          ctx.restore();
        }
      }

      function drawParticles() {
        for (const p of particles) {
          const t = p.elapsed / p.life;
          const alpha = (1 - t) * 0.8;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.shadowColor = `hsla(${p.hue}, 90%, 60%, 1)`;
          ctx.shadowBlur = 14;
          ctx.fillStyle = `hsla(${p.hue}, 90%, 60%, 1)`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, 2.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
      }

      function drawPowerups() {
        for (const p of powerups) {
          const pulse = 0.7 + Math.sin(performance.now() / 200 + p.x) * 0.15;
          const radius = p.radius * pulse;

          ctx.save();
          ctx.translate(p.x, p.y);

          let baseColor, glowColor;
          if (p.type === POWERUP.SHIELD) {
            baseColor = "rgba(255,228,94,0.9)";
            glowColor = "rgba(255,228,94,0.45)";
          } else if (p.type === POWERUP.SLOW) {
            baseColor = "rgba(123,255,181,0.9)";
            glowColor = "rgba(123,255,181,0.45)";
          } else if (p.type === POWERUP.BURST) {
            baseColor = "rgba(255,156,245,0.9)";
            glowColor = "rgba(255,156,245,0.45)";
          } else {
            baseColor = "rgba(78,163,255,0.9)";
            glowColor = "rgba(78,163,255,0.45)";
          }

          const grad = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 2);
          grad.addColorStop(0, glowColor);
          grad.addColorStop(1, "rgba(0,0,0,0)");
          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.arc(0, 0, radius * 2, 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowColor = baseColor;
          ctx.shadowBlur = 12;
          ctx.fillStyle = baseColor;
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
          ctx.fill();

          ctx.shadowBlur = 0;
          ctx.lineWidth = 1.6;
          ctx.strokeStyle = "rgba(0,0,0,0.55)";
          ctx.beginPath();
          if (p.type === POWERUP.SHIELD) {
            ctx.moveTo(-radius * 0.4, -radius * 0.1);
            ctx.lineTo(0, -radius * 0.6);
            ctx.lineTo(radius * 0.4, -radius * 0.1);
            ctx.quadraticCurveTo(0, radius * 0.8, -radius * 0.4, -radius * 0.1);
          } else if (p.type === POWERUP.SLOW) {
            ctx.moveTo(-radius * 0.5, -radius * 0.3);
            ctx.lineTo(radius * 0.2, -radius * 0.3);
            ctx.lineTo(radius * 0.5, radius * 0.3);
            ctx.lineTo(-radius * 0.2, radius * 0.3);
            ctx.closePath();
          } else if (p.type === POWERUP.BURST) {
            ctx.moveTo(-radius * 0.4, -radius * 0.4);
            ctx.lineTo(radius * 0.4, radius * 0.4);
            ctx.moveTo(radius * 0.4, -radius * 0.4);
            ctx.lineTo(-radius * 0.4, radius * 0.4);
          } else {
            // Dash: flecha
            ctx.moveTo(-radius * 0.5, 0);
            ctx.lineTo(radius * 0.2, 0);
            ctx.lineTo(radius * 0.1, -radius * 0.3);
            ctx.moveTo(radius * 0.2, 0);
            ctx.lineTo(radius * 0.1, radius * 0.3);
          }
          ctx.stroke();

          ctx.restore();
        }
      }

      function render() {
        drawBackground();
        drawEnemies();
        drawParticles();
        drawPowerups();
        drawPlayer();

        if (currentState === STATE.PAUSED) {
          ctx.save();
          ctx.fillStyle = "rgba(0,0,0,0.4)";
          ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
          ctx.fillStyle = "rgba(255,255,255,0.9)";
          ctx.font = "24px system-ui";
          ctx.textAlign = "center";
          ctx.fillText("Pausa", GAME_WIDTH / 2, GAME_HEIGHT / 2);
          ctx.restore();
        }
      }

      function gameLoop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;

        update(dt);
        render();

        requestAnimationFrame(gameLoop);
      }

      setState(STATE.MENU);
      requestAnimationFrame(gameLoop);
    })();
  </script>
</body>
</html>